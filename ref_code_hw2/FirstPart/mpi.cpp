#include <assert.h>#include <math.h>#include <mpi.h>#include <stdlib.h>#include <stdio.h>#include <stddef.h>#include <vector>#include "common.h"// maximum number of partitions for each axis#define PA pair<int, int>#define VIT vector<int>::iterator#define MAX_PARTITIONS 1000#define MAX_NUM_PROC 1000// Struct used to pass around information; the differences// between this and particle_t are (1) this includes index// and (2) this does not include ax, ay.typedef struct {  double x;  double y;  double vx;  double vy;  int ind;} particle_with_index;const int SAVE_TAG = 1;const int TAG_OFFSET = 2;using namespace std;// This is a buffer for recording which particles we want to send to// each processorvector<int> rank_to_particle[MAX_NUM_PROC];bool is_recved[MAX_NUM_PROC];vector<int> bin[MAX_PARTITIONS][MAX_PARTITIONS];vector<PA> local_bins, close_bins;int bin_rank[MAX_PARTITIONS][MAX_PARTITIONS], num_partitions;double plane_size, partition_size;MPI_Datatype PARTICLE_WITH_INDEX;// helper function whether the indices correspond to a valid bininline bool is_bin_in_range(int i, int j) {    return (i >= 0 && i < num_partitions && j >= 0 && j < num_partitions);}// compute which processor bin i, j is assigned toinline int compute_rank_for_bin(int i, int j, int n_proc) {    if (!is_bin_in_range(i, j)) return -1;    // return (i + j) % n_proc;    return i % n_proc;}// Compute rank for each bin and compute the local bins and// the bins that are adjacent to local binsinline void assign_rank_for_bin(int rank, int n_proc) {    for (int i = 0 ; i < num_partitions ; i++) {        for (int j = 0 ; j < num_partitions ; j++) {            bin_rank[i][j] = compute_rank_for_bin(i, j, n_proc);            if (bin_rank[i][j] == rank) local_bins.push_back(PA(i, j));       }    }    for (int i = 0 ; i < num_partitions ; i ++) {        for (int j = 0 ; j < num_partitions ; j ++) {            if (bin_rank[i][j] == rank) continue;            bool close = false;            for (int k = i - 1 ; k <= i + 1 ; k ++) {                for (int l = j - 1 ; l <= j + 1 ; l ++) {                    if (compute_rank_for_bin(k, l, n_proc) == rank) close = true;                }            }            if (close) close_bins.push_back(PA(i, j));        }    }}// Helper function for sending particles to another processorinline void send(int dest, int tag, particle_with_index* buffer, particle_t* particles) {    for (int i = 0 ; i < rank_to_particle[dest].size() ; i ++) {        int ind = rank_to_particle[dest][i];        buffer[i].x = particles[ind].x;        buffer[i].y = particles[ind].y;        buffer[i].vx = particles[ind].vx;        buffer[i].vy = particles[ind].vy;        buffer[i].ind = ind;    }    int send_size = rank_to_particle[dest].size();    MPI_Request req;    MPI_Isend(buffer, send_size, PARTICLE_WITH_INDEX, dest, tag, MPI_COMM_WORLD, &req);}inline bool probe(int src, int tag) {    int flag;    MPI_Status stat;    MPI_Iprobe(src, tag, MPI_COMM_WORLD, &flag, &stat);    return (flag == 1);}// Helper function for receiving particles from another processorinline void recv(int src, int tag, particle_with_index* buffer, particle_t* particles, bool update_bin, int n) {    int recv_size =0;    MPI_Status stat;    MPI_Recv (buffer, 3*n, PARTICLE_WITH_INDEX, src,tag, MPI_COMM_WORLD, &stat);    MPI_Get_count(&stat,PARTICLE_WITH_INDEX,&recv_size);    for (int i = 0 ; i < recv_size ; i ++) {        int ind = buffer[i].ind;        particles[ind].x = buffer[i].x;        particles[ind].y = buffer[i].y;        particles[ind].vx = buffer[i].vx;        particles[ind].vy = buffer[i].vy;        if (update_bin) {            int px = (int)(particles[ind].x / partition_size);            int py = (int)(particles[ind].y / partition_size);            bin[px][py].push_back(ind);        }    }}// Figure out which processors this particle should be sent toinline void compute_rank_to_send(particle_t &particle, int ind, int rank) {    int px = (int)(particle.x / partition_size);    int py = (int)(particle.y / partition_size);    for (int k = px - 1 ; k <= px + 1 ; k ++) {        for (int l = py - 1 ; l <= py + 1 ; l ++) {            if (is_bin_in_range(k, l) && bin_rank[k][l] != rank) {                if (rank_to_particle[bin_rank[k][l]].size() == 0 ||                     rank_to_particle[bin_rank[k][l]].back() != ind) {                    rank_to_particle[bin_rank[k][l]].push_back(ind);                }            }        }    }}//// main program//int main (int argc, char **argv) {        int rnavg, navg, nabsavg=0;    double dmin, absmin=1.0, davg, absavg=0.0, rdavg, rdmin;     //    // process command line parameters    //    if (find_option(argc, argv, "-h") >= 0) {        printf("Options:\n");        printf("-h to see this help\n");        printf("-n <int> to set the number of particles\n");        printf("-o <filename> to specify the output file name\n");        printf("-s <filename> to specify a summary file name\n");        printf("-no turns off all correctness checks and particle output\n");        return 0;    }        int n = read_int(argc, argv, "-n", 1000);    char *savename = read_string(argc, argv, "-o", NULL);    char *sumname = read_string(argc, argv, "-s", NULL);        //    // set up MPI    //    int n_proc, rank;    MPI_Init(&argc, &argv);    MPI_Comm_size(MPI_COMM_WORLD, &n_proc);    MPI_Comm_rank(MPI_COMM_WORLD, &rank);        //    // allocate generic resources    //    FILE *fsave = savename ? fopen(savename, "w") : NULL;    FILE *fsum = sumname ? fopen (sumname, "a") : NULL;    const int nitems=2;    int blocklengths[2] = {4, 1};    MPI_Datatype types[2] = {MPI_DOUBLE, MPI_INT};    MPI_Aint offsets[2] = {0, offsetof(particle_with_index, ind)};    MPI_Type_create_struct(nitems, blocklengths, offsets, types, &PARTICLE_WITH_INDEX);    MPI_Type_commit(&PARTICLE_WITH_INDEX);        //    // set up the data partitioning across processors    //    // partition space into (num_partitions) x (num_partitions) grid    //    // don't pick num_partitions to be too big; the current running time     // and memory usage depends on num_partitions^2    set_size(n);    num_partitions = MAX_PARTITIONS;    particle_t *particles = (particle_t*) malloc(n * sizeof(particle_t));    particle_with_index *buff = (particle_with_index*) malloc(3 * n * sizeof(particle_with_index));    particle_with_index *recv_buff = (particle_with_index*) malloc(n * sizeof(particle_with_index));    particle_with_index* buff_with_offset = buff;    plane_size = get_size();    partition_size = max(cutoff, plane_size / num_partitions);     // Compute rank from the process each processor is assigned to and    // fill in bin_rank. Store the local bins in local_bins and bins that    // are adjacent to local bins in close_bins.    assign_rank_for_bin(rank, n_proc);     if (rank == 0) {        init_particles(n, particles);        // this is the special case; the master sends every particles to other processors        for (int i = 0 ; i < n ; i ++) compute_rank_to_send(particles[i], i, rank);        // put particles in the right bin        for (int i = 0 ; i < n ; i ++) {            int px = (int)(particles[i].x / partition_size);            int py = (int)(particles[i].y / partition_size);            bin[px][py].push_back(i);        }        for (int i = 1 ; i < n_proc ; i ++) {            send(i, 0, buff_with_offset, particles);            buff_with_offset += rank_to_particle[i].size();        }    } else recv(0, 0, recv_buff, particles, true, n);    //    //  simulate a number of time steps    //    double simulation_time = read_timer();    for (int step = 0 ; step < NSTEPS ; step ++) {        navg = 0;        dmin = 1.0;        davg = 0.0;        buff_with_offset = buff;        //        //  save current step if necessary        //        if (find_option( argc, argv, "-no" ) == -1 && fsave && (step % SAVEFREQ) == 0) {            if (step != 0) {                if (rank != 0) {                    // if this is not the master processor, send everything to the master                    rank_to_particle[0].clear();                    for (int i = 0 ; i < local_bins.size() ; i ++) {                        int px = local_bins[i].first;                        int py = local_bins[i].second;                        for (int j = 0 ; j < bin[px][py].size() ; j ++) {                            rank_to_particle[0].push_back(bin[px][py][j]);                        }                    }                    send(0, SAVE_TAG, buff_with_offset, particles);                    buff_with_offset += rank_to_particle[0].size();                } else {                    // if this is the master, receive from everyone else                    for (int i = 1 ; i < n_proc ; i ++) {                        recv(i, SAVE_TAG, recv_buff, particles, false, n);                    }                }            }            if (rank == 0) save(fsave, n, particles);        }        // clear the bins that are adjacent to the bins corresponding to this processor        for (int i = 0 ; i < close_bins.size() ; i ++) {            bin[close_bins[i].first][close_bins[i].second].clear();        }        // clear the particles that we want to send to each processor        for (int i = 0 ; i < n_proc ; i ++) rank_to_particle[i].clear();        if (step != 0) {            // compute where each particle should be sent            for (int i = 0 ; i < local_bins.size() ; i ++) {                int px = local_bins[i].first;                int py = local_bins[i].second;                for (int j = 0 ; j < bin[px][py].size() ; j ++) {                    compute_rank_to_send(particles[bin[px][py][j]], bin[px][py][j], rank);                }            }            // Send particles accordingly            for (int i = 0 ; i < n_proc ; i ++) {                if (i != rank) {                    send(i, TAG_OFFSET + step % 2, buff_with_offset, particles);                    buff_with_offset += rank_to_particle[i].size();                }            }            // update each particle's bin            for (int i = 0 ; i < local_bins.size() ; i ++) {                int ix = local_bins[i].first;                int iy = local_bins[i].second;                for (VIT it = bin[ix][iy].begin() ; it != bin[ix][iy].end() ; ) {                    int px = (int)(particles[*it].x / partition_size);                    int py = (int)(particles[*it].y / partition_size);                    if (px != ix || py != iy) {                        bin[px][py].push_back(*it);                        it = bin[ix][iy].erase(it);                    } else it ++;                }            }            // Receive particles from other processors            int cnt_recv = 0;            for (int i = 0 ; i < n_proc ; i ++) is_recved[i] = false;            while (cnt_recv < n_proc - 1) {                for (int i = 0 ; i < n_proc ; i ++) {                    if (i != rank && !is_recved[i] && probe(i, TAG_OFFSET + step % 2)) {                        is_recved[i] = true;                        cnt_recv ++;                        recv(i, TAG_OFFSET + step % 2, recv_buff, particles, true, n);                     }                }            }        }                //        //  compute all forces        //        // TODO(pasin): remove the summing and debugging here        int sum = 0;        for (int i = 0 ; i < local_bins.size() ; i ++) {            int px = local_bins[i].first;            int py = local_bins[i].second;            for (int j = 0 ; j < bin[px][py].size() ; j ++) {                sum ++;                int ind = bin[px][py][j];                particles[ind].ax = particles[ind].ay = 0;                for (int k = px - 1 ; k <= px + 1 ; k ++) {                    for (int l = py - 1 ; l <= py + 1 ; l ++) {                        if (!is_bin_in_range(k, l)) continue;                        for (VIT it = bin[k][l].begin() ; it != bin[k][l].end() ; it ++) {                            apply_force(particles[ind], particles[*it], &dmin, &davg, &navg);                        }                    }                }            }        }        //if (step % 200 == 0) printf("Step %d: Processor %d has %d particles.\n", step, rank, sum);                //        // Computing statistical data        //        if (find_option( argc, argv, "-no" ) == -1) {            MPI_Reduce(&davg, &rdavg, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);            MPI_Reduce(&navg, &rnavg, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);            MPI_Reduce(&dmin, &rdmin, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);            if (rank == 0) {                if (rnavg) {                    absavg +=  rdavg/rnavg;                    nabsavg++;                }                if (rdmin < absmin) absmin = rdmin;            }        }        //        //  move particles        //        for (int i = 0 ; i < local_bins.size() ; i ++) {            int px = local_bins[i].first;            int py = local_bins[i].second;            for (int j = 0 ; j < bin[px][py].size() ; j ++) {                move(particles[bin[px][py][j]]);            }        }    }    simulation_time = read_timer() - simulation_time;      if (rank == 0) {        printf( "n = %d, simulation time = %g seconds", n, simulation_time);      if (find_option(argc, argv, "-no") == -1) {        if (nabsavg) absavg /= nabsavg;        //         //  -The minimum distance absmin between 2 particles during the run of the simulation        //  -A Correct simulation will have particles stay at greater than 0.4 (of cutoff) with typical values between .7-.8        //  -A simulation where particles don't interact correctly will be less than 0.4 (of cutoff) with typical values between .01-.05        //        //  -The average distance absavg is ~.95 when most particles are interacting correctly and ~.66 when no particles are interacting        //        printf( ", absmin = %lf, absavg = %lf", absmin, absavg);        if (absmin < 0.4) printf ("\nThe minimum distance is below 0.4 meaning that some particle is not interacting");        if (absavg < 0.8) printf ("\nThe average distance is below 0.8 meaning that most particles are not interacting");      }      printf("\n");                   //        // Printing summary data      //        if(fsum) fprintf(fsum,"%d %d %g\n",n,n_proc,simulation_time);    }      //    //  release resources    //    if (fsum) fclose(fsum);    free(particles);    free(buff);    free(recv_buff);    if(fsave) fclose(fsave);        MPI_Finalize();        return 0;}